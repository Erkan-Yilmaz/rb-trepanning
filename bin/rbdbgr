#!/usr/bin/env ruby
# -*- Ruby -*-
# Invoke debugger from the command line. 

require_relative %w(.. rbdbgr)

module Rbdbgr
  require 'rbconfig'

  # Return an ARRAY which makes explicit what array to pass system()
  # to reinvoke this debugger. We want to make explicit both the Ruby
  # interpreter used and the file name of the program to debug.
  def explicit_restart_argv(argv)
    %W(#{ruby_path} #{File.expand_path($0)}) + argv
  end

  # Path name of ruby interpreter we were invoked with.
  def ruby_path
    File.join(Config::CONFIG['bindir'], 
              Config::CONFIG['RUBY_INSTALL_NAME'])
  end

  # Given a Ruby interpreter and program we are to debug, debug it.
  # The caller must ensure that ARGV is set up to remove any debugger
  # arguments or things that the debugged program isn't supposed to
  # see.  FIXME: Should we make ARGV an explicit parameter?
  def debug_program(dbgr, ruby_path, program_to_debug)

    # Make sure Ruby script syntax checks okay.
    # Otherwise we get a load message that looks like rbdbgr has 
    # a problem. 
    output = `#{ruby_path} -c #{program_to_debug} 2>&1`
    if $?.exitstatus != 0 and RUBY_PLATFORM !~ /mswin/
      puts output
      exit $?.exitstatus 
    end
    # print "\032\032starting\n" if Debugger.annotate and Debugger.annotate > 2

    dbgr.trace_filter.excluded << self.method(:debug_program)
    old_dollar_0 = $0
    $0 = program_to_debug
    dbgr.debugger do
      load program_to_debug
    end
    $0 = old_dollar_0
  end

  # Do a shell-like path lookup for prog_script and return the results.
  # If we can't find anything return prog_script.
  def whence_file(prog_script)
    if prog_script.index(File::SEPARATOR)
      # Don't search since this name has path separator components
      return prog_script
    end
    for dirname in ENV['PATH'].split(File::PATH_SEPARATOR) do
      prog_script_try = File.join(dirname, prog_script)
      return prog_script_try if File.readable?(prog_script_try)
    end
    # Failure
    return prog_script
  end
end

if __FILE__ == $0
  include Rbdbgr

  # One way to get local variables is to create a block which is run
  # once.  
  # 
  # Note however that since we are constants below, we can't
  # wrap all of this in a procedure as that would be defining
  # constants dynamically.
  1.times do 
    | ; rbdbgr_path, program_to_debug |
    if ARGV.empty?
      STDERR.puts 'Sorry - for now you must specify a Ruby script to debug.'
      exit(-1)
    end
    
    Debugger::ARGV = ARGV.clone

    rbdbgr_path = File.expand_path($0)
    if RUBY_PLATFORM =~ /mswin/
      rbdbgr_path += '.cmd' unless rbdbgr_path =~ /\.cmd$/i
    end

    # FIXME: do we need to test defined? 
    # FIXME: Should (some of) these be instance variables?
    Debugger::RUBY_PATH    = ruby_path
    Debugger::RBDBGR_PATH  = rbdbgr_path
    Debugger::RBDBGR_FILE  = __FILE__
    Debugger::INITIAL_DIR  = Dir.pwd

    program_to_debug = ARGV.shift
    program_to_debug = whence_file(program_to_debug) unless 
      File.exist?(program_to_debug)
    Debugger::PROG_SCRIPT = program_to_debug

    # Set global so others may use this debugger.
    $rbdbgr = Debugger.new(:restart_argv => 
                           explicit_restart_argv(Debugger::ARGV))
    debug_program($rbdbgr, Debugger::RUBY_PATH, 
                  File.expand_path(program_to_debug))
  end
end
